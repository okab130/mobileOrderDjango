# AIによるテスト実施ガイド

## 目次
1. [AIが使用するテスト技術](#1-aiが使用するテスト技術)
2. [テスト依頼の方法](#2-テスト依頼の方法)
3. [提示すべき情報](#3-提示すべき情報)
4. [テストの種類別ガイド](#4-テストの種類別ガイド)
5. [実践例](#5-実践例)

---

## 1. AIが使用するテスト技術

### 1.1 実行環境でのテスト

#### PowerShellコマンド実行
- **用途**: サーバー起動、スクリプト実行、コマンドラインツールの操作
- **できること**:
  - アプリケーションの起動と動作確認
  - テストスクリプトの実行
  - ビルドとデプロイ
  - データベース操作

**例:**
```powershell
# Djangoサーバー起動
python manage.py runserver

# テスト実行
python manage.py test

# Pytestの実行
pytest tests/ -v

# Node.jsアプリのテスト
npm test
```

#### ブラウザ自動化（間接的）
- **制約**: AIは直接ブラウザを操作できない
- **代替手段**:
  - curlやHTTPリクエストでAPI/エンドポイントテスト
  - Seleniumスクリプトの作成と実行依頼
  - Playwrightスクリプトの作成と実行依頼

### 1.2 コード解析によるテスト

#### 静的解析
- **Linter実行**: flake8, pylint, ESLint等
- **型チェック**: mypy, TypeScript compiler
- **セキュリティスキャン**: bandit, safety

**例:**
```powershell
# Python静的解析
flake8 .
pylint app/

# JavaScript/TypeScript
eslint src/
tsc --noEmit

# セキュリティチェック
bandit -r .
safety check
```

#### コードレビュー
- ファイル内容を読み取り、論理エラーを検出
- ベストプラクティス違反の指摘
- セキュリティ脆弱性の発見

### 1.3 自動テストフレームワーク

#### Python
- **unittest**: Django標準
- **pytest**: 柔軟なテストフレームワーク
- **coverage**: カバレッジ測定

```python
# tests/test_models.py
import pytest
from django.test import TestCase
from order.models import Session

class SessionModelTest(TestCase):
    def test_create_session(self):
        session = Session.objects.create(
            table_id=1,
            party_size=4
        )
        self.assertEqual(session.status, 'ACTIVE')
```

#### JavaScript/TypeScript
- **Jest**: ユニットテスト
- **Mocha/Chai**: テストフレームワーク
- **Cypress/Playwright**: E2Eテスト

#### API テスト
- **curl**: HTTPリクエスト
- **httpie**: 人間に優しいHTTPクライアント
- **Postman CLI (newman)**: APIテスト自動化

---

## 2. テスト依頼の方法

### 2.1 基本的な依頼形式

#### ❌ 悪い例
```
「テストしてください」
「動くか確認して」
```
→ 何をどうテストするか不明

#### ✅ 良い例
```
「注文機能のユニットテストを実行して、結果を報告してください」
「ログイン機能が正しく動作するか、以下のシナリオでテストしてください：
1. 正しいユーザー名とパスワードでログイン成功
2. 間違ったパスワードでログイン失敗
3. 存在しないユーザーでログイン失敗」
```

### 2.2 依頼文の構成要素

```
[テストの目的] + [対象機能] + [期待する動作] + [制約条件]
```

**テンプレート:**
```
【テスト目的】
[新機能のリグレッションテスト/バグ修正の確認/性能測定]

【対象機能】
[具体的な機能名やファイル名]

【テストシナリオ】
1. [ステップ1]
2. [ステップ2]
3. [期待される結果]

【環境】
- OS: [Windows/macOS/Linux]
- Python/Node.jsバージョン: [X.X]
- データベース: [SQLite/PostgreSQL]

【前提条件】
- [必要な初期データ]
- [必要な環境変数]
```

---

## 3. 提示すべき情報

### 3.1 必須情報

#### システム構成
```markdown
- プロジェクトディレクトリ: C:\path\to\project
- 使用言語: Python 3.11
- フレームワーク: Django 4.2
- データベース: SQLite
- テストフレームワーク: pytest
```

#### テスト対象
```markdown
- テストファイル: tests/test_order.py
- テスト対象モジュール: order/views.py
- テスト範囲: 注文作成から完了まで
```

#### 期待動作
```markdown
- 入力: {"menu_item_id": 1, "quantity": 2}
- 期待出力: {"success": true, "order_id": 123}
- エラーケース: quantity > 10 の場合、400エラー
```

### 3.2 推奨情報

#### テストデータ
```markdown
- テストユーザー: username=testuser, password=test123
- テストセッション: table=1, party_size=4
- テスト商品: menu_item_id=1 (ハンバーガー, 1000円)
```

#### 環境設定
```markdown
- 環境変数: DEBUG=True
- データベース: test.sqlite3
- ポート: 8000
```

#### 制約・注意事項
```markdown
- 本番データベースは触らない
- テスト実行時はサーバーを停止する
- テスト後はデータをクリーンアップする
```

---

## 4. テストの種類別ガイド

### 4.1 ユニットテスト

**目的**: 個別の関数やメソッドの動作確認

**依頼例:**
```
「order/models.py の Session モデルに対するユニットテストを作成し、実行してください。

テスト項目:
1. セッション作成時、statusが'ACTIVE'になること
2. total_amountの計算が正しいこと
3. セッション完了時、completed_atが設定されること」
```

**AIが実施すること:**
1. テストコードの作成
2. `python manage.py test` または `pytest` の実行
3. 結果レポート

### 4.2 統合テスト

**目的**: 複数のコンポーネントの連携確認

**依頼例:**
```
「注文フロー全体の統合テストを実行してください。

フロー:
1. セッション作成
2. メニュー取得
3. 注文作成
4. 注文ステータス更新
5. 会計完了

各ステップでデータベースの状態を確認してください。」
```

**AIが実施すること:**
1. Django TestCaseを使用した統合テスト作成
2. トランザクション内でのテスト実行
3. データベース状態の確認

### 4.3 APIテスト

**目的**: REST APIエンドポイントの動作確認

**依頼例:**
```
「以下のAPIエンドポイントをテストしてください：

POST /api/orders
- Body: {"session_id": 1, "menu_item_id": 1, "quantity": 2}
- 期待: 201 Created, order_idを返す
- エラー: quantity=0の場合、400 Bad Request

GET /api/orders/1
- 期待: 200 OK, 注文詳細を返す
- エラー: 存在しないID、404 Not Found」
```

**AIが実施すること:**
1. curlコマンドまたはPythonのrequestsライブラリを使用
2. レスポンスコードとボディの検証
3. エラーケースの確認

### 4.4 性能テスト

**目的**: 負荷やレスポンス時間の測定

**依頼例:**
```
「メニュー一覧取得APIの性能テストを実施してください。

測定項目:
1. 100件の商品データでのレスポンス時間
2. 1000件の商品データでのレスポンス時間
3. 10並列リクエストでの平均レスポンス時間

目標: 100件で100ms以内」
```

**AIが実施すること:**
1. テストデータの準備
2. Apache BenchやPythonスクリプトで負荷測定
3. 結果の分析とレポート

### 4.5 セキュリティテスト

**目的**: 脆弱性の検出

**依頼例:**
```
「以下のセキュリティテストを実施してください：

1. SQLインジェクション脆弱性チェック
2. XSS脆弱性チェック
3. CSRF保護の確認
4. 認証なしでのアクセス制限確認
5. パスワードハッシュ化の確認」
```

**AIが実施すること:**
1. セキュリティスキャンツールの実行
2. 手動での脆弱性パターン検証
3. Django設定の確認

---

## 5. 実践例

### 5.1 モバイルオーダーシステムのテスト例

#### 例1: 注文機能のテスト

**依頼:**
```
「モバイルオーダーシステムの注文機能をテストしてください。

【環境】
- プロジェクト: C:\Users\user\gh\mobileOrderDjango
- 仮想環境: venv

【前提条件】
- python manage.py init_data でデータ投入済み
- テーブル1のセッションが存在
- 商品ID=1が存在

【テストシナリオ】
1. セッション作成
2. 商品ID=1を数量2で注文
3. 注文一覧に表示されることを確認
4. ステータスがPENDINGであることを確認

【期待結果】
- 注文が正常に作成される
- total_amountが正しく計算される
- データベースに保存される」
```

**AIの実施内容:**
```python
# tests/test_order_flow.py を作成
from django.test import TestCase, Client
from order.models import Session, Order, MenuItem

class OrderFlowTest(TestCase):
    def setUp(self):
        self.client = Client()
        # 初期データ準備
        
    def test_create_order(self):
        # テストコード
        pass
```

その後:
```bash
python manage.py test tests.test_order_flow
```

---

## 6. 効果的なテスト依頼のチェックリスト

### テスト依頼前の確認

- [ ] テストの目的が明確か
- [ ] テスト対象が具体的に指定されているか
- [ ] 期待される動作が明確か
- [ ] 必要な前提条件が記載されているか
- [ ] テスト環境の情報が提供されているか
- [ ] テストデータの準備方法が明確か
- [ ] 成功/失敗の判断基準が明確か

---

## 7. まとめ

### AIによるテストの強み

✅ **24時間実行可能**: 時間を問わずテスト実施
✅ **再現性が高い**: 同じ条件で何度でも実行
✅ **自動化が得意**: スクリプト作成と実行
✅ **包括的なチェック**: 静的解析からE2Eまで

### AIによるテストの制約

❌ **ブラウザ直接操作は不可**: Seleniumスクリプト作成で代替
❌ **視覚的な判断は困難**: UI/UXの評価は人間が必要
❌ **複雑な判断は苦手**: ビジネスロジックの妥当性判断
❌ **環境依存の問題**: ローカル環境の制約を受ける

### 効果的なテスト依頼の原則

1. **明確な目的を持つ**: 何を確認したいかを明確に
2. **具体的な指示**: テストシナリオを詳細に記述
3. **十分な情報提供**: 環境、データ、期待値を提示
4. **段階的に実施**: 小さいテストから始める
5. **結果を検証**: AIの報告を人間が最終確認

---

**このガイドを活用して、効果的なテストをAIに依頼してください！**
